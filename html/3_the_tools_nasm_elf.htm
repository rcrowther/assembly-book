<!DOCTYPE html><html><head><title>3_the_tools_nasm_elf</title><meta http-equiv="content-type" content="text/html; charset=UTF-8" /><link rel="stylesheet" type="text/css" media="screen" href="../lib/doc.css"/></head><body><article><h1>3 The tools, NASM and ELF</h1><h2>What you need</h2><p>Linux. Nearly any Linux will do.</p><p>If you have an rpm or Debian package system, easy. Install,</p><ul><li>’gcc’</li><li>’nasm’</li></ul><p>and pick a text editor. Gedit or Kate will work fine (yes they will)… or EMACS, vi, nano, Gleany etc. But don’t use a word processor, it will be slow and may cause trouble with encodings.</p><p>If you were wondering about the usual problem of packages being out‐of‐date, don’t. Assembly language has been around since the 1960’s—these programs, for the behaviour we need, are stable. And, though they may depend on other packages, the programs are self‐contained—one is not going to mess with another.</p><p>All in all, this is maybe the easiest start in a programming language you will ever have.</p><p>While we are waiting, let’s look at why we want them.</p><h2>Linux</h2><p>For various reasons, Linux is easier for assembly language. I run out of reasons—the distributions are readily available, it can can be easily installed on computers (even an old computer), it’s easy to see and navigate files, programs are readily available in repositories, it has a superior commandline for running the programs, it has more logical handling of the CPU… I give up. I’ll likely think of more later.</p><p>We use Linux.</p><h2>NASM, the compiler</h2><p>Many assemblers have been built. On the web,</p><dd><dd>TASM</dd><dt>Turbo Assembler from the company Borland</dt><dd>MASM</dd><dt>Microsoft assembler</dt><dd>YASM</dd><dt>Pluggable Open‐Source assembler. Modular update of NASM, handles both AT&T and Intel syntax.</dt><dd>GAS</dd><dt>Original Linux assembler, used to backend GCC, the Open‐Source compiler behind Linux. Originally used AT&T syntax.</dt><dd>NASM</dd><dt>Open Source compiler with BSD License. Uses Intel syntax.</dt></dd><p>For the compiler, we’ll use NASM. NASM uses Intel syntax. Intel syntax is much easier than the old Open Source GAS syntax. NASM is also freely available in Linux package repositories. It well documented and less confusing than the admittedly impressive YASM.</p><h2>ELF, the output file format</h2><p>Many forms of output files exist. We will use ELF ‘object files’.</p><p>ELF stands for Executable and Linkable Object Format. It’s the main compiled file format for many operating systems including FreeBSD or GNU/Linux.</p><p>Linkable means lots of little files can be made with unresolved symbols in them. You state a method, but there is no code available. But the making of an ELF does not complain. Then, with all the files gathered together, a linking program joins the symbols together and generates working code.</p><p>The two steps of compile/link are a serious usability issue in the work chain of making code. Most higher‐level languages avoid them. But the two‐step process has a few advantages, and they are big advantages. First, when making changes to code, unchanged files do not need to be recompiled—using the linker, they can be glued in for the new code. This is much faster. Second, files with accessible symbols can dropped into a system, for other code to use—they become a library.</p><p>In a Linux/Unix system, ELf files appear in three forms,</p><ul><li>Shared object files (conventionally named .so)</li><li>Relocatable object files (conventionally named .o)</li><li>Executable files (no convention, often the name of the program)</li></ul><h3>ELF in general</h3><p>ELF files have a header and segments.</p><p>Segments are the elements ELF files use when they run, or are run. Segments may hold text, data, stacks etc. Segments contains one or more sections.</p><p>Assemblers like NASM can handle segments. This means they can, for example, generate output files handling a mix of 16‐bit and 32‐bit code. In this tutorial we do not discuss segments (this is not about output formats). However, you may find the words popping up. Since the reference documentation is not clear about this, it’s good to know the difference.</p><p>ELF holds data and function code, both referenced by symbols. ELF keeps track of how big symbols are, whether they are weak, are they data or functions… that kind of information.</p><h3>ELF sections</h3><p>Each section has a seperate use. Each section has a distinct combination of flags (and these flags can be changed). To talk about the flag sets is too deep for us—see YASM documentation for a quick introduction.</p><p>We will use sections. The standard ELF sections are,</p><dl><dd>.bss</dd><dt>Runtime disc loaded, writable</dt><dd>.data</dd><dt>Runtime disc loaded</dt><dd>.rodata</dd><dt>Runtime disc loaded, writable</dt><dd>.text</dd><dt>Runtime disc loaded, executable</dt><dd>.comment</dd><dt>disc stored</dt></dl><p>Don’t fret… when we come to use this information, I’ll repeat it.</p><h3>Looking at ELF files</h3><p>ELF can be read using a Linux utility called ‘readelf’. This is often available pre‐installed on systems like Ubuntu. To display all info (very large output!),</p><pre><code>> readelf -a <file></code></pre><p>To display symbols only,</p><pre><code>> readelf -s <file></code></pre><p>The output is informative. Some may say, scary. Let’s stick with informative.</p><ul><dd>Wikipedia on ELF format,</dd><dt><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></dt></ul><h2>GCC, the linker</h2><p>We need GCC (the Open Source C and other low‐level language compiler) for linking.</p><p>When we produce an ELF file, it likely will not run on it’s own. Yes, machine code files can be made which do everything themselves. After all, other computer languages ultimately spew out machine code, so anything they can do, machine code can do. Some machine coders are hired because they can do everything without any help, and that can make files small, small, small.</p><p>However, writing stand‐alone machine code is costly. And these posts are a tutorial. I don’t think it’s much of a tutorial hauling you through fifty, one hundred, lines of code so we can print out results. We need some help—we need someone else’s code welded to ours.</p><p>Which means, once we have written code, using a linker to join our code to other code. Well, GCC has that code built‐in. So we don’t have to fight with all the usual horrible compiler lines. Two wins, useful code, and easy compilation (the only loss is that GCC is a horrible lump to download).</p><h2>Where we at?</h2><p>Ready to go.</p></article></body></html>