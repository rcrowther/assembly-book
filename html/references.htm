<!DOCTYPE html><html><head><title>References</title><meta http-equiv="content-type" content="text/html; charset=UTF-8" /><link rel="stylesheet" type="text/css" media="screen" href="../lib/doc.css"/></head><body><article><p>First, in 64‐bit especially, we need to talk addresses (pointers).</p><h2>Addresses and constants</h2><p>NASM documentation makes a play that NASM handling of addresses is a simple system compared to TASM and MASM. YASM documentation (based in NASM with often useful additions) talks about ‘Effective addresses’. Personally, I find the descriptions, while historically vital, confused. Are they talking about addresses (references), or getting contents (de‐referencing)? The descriptions further seem contradictory—is an ‘memory address’ getting an address or contents?</p><p>Far as I can tell the situation is this:</p><p>The NASM (and YASM) syntax for symbols always produces symbols. That means a compiler construct which allows us to refer to something. The something can be an address or a constant (from the compiler documentation, this was not the case in MASM and TASM. Symbols in some constructions referred to actual references, etc.).</p><p>The ‘d(x)’ class of instructions allocate a piece of memory. Writable or not, the result is an address and a piece of memory (contents).</p><pre><code>limit: dq 32</code></pre><p>NASM has a separate statement for a piece of memory without an address,</p><pre><code>limitConst equ 32</code></pre><p>(of course, this is data at an address. However, the address is obscured, usable only through the symbol, which returns the data)</p><p>Similar to C array notation, a symbol with no brackets means an address, a symbol with square brackets means an access.</p><p>Thus,</p><pre><code>limit           ; gets the address of limit ()
[limit]         ; gets the contents of the 'limit' address
limitConst      : gets the limitConst
[limitConst]    ; treats limitConst as an address, returning ''Segmentation fault'</code></pre><p>also,</p><pre><code>rax           ; gets the address of rax (valid, but rarely intended)
[rax]         ; gets the contents of register 'rax'</code></pre><p>However, this analogy only goes so far. Really, the square brackets mean “Treat eveything inside the brackets as a reference”. So,</p><pre><code>rax           ; gets the contents of rax (valid, but rarely intended)
[rax]         ; gets the contents of the address in register 'rax'</code></pre><h2>Relative addressing</h2><p>Unwriten in documentation</p><p>Addresses are measured in bytes. Larger size numerics are held in a consecutive set of bytes. A quadword (64‐bit) is madde of eight bytes. reading them from left to right, as a human would on paper, looks in memory like this,</p><p>byte1</p><p>byte2</p><p>byte3</p><p>byte4</p><p>byte5</p><p>byte6</p><p>byte7</p><p>byte8</p><p>Intel documentation.</p><blockquote><p>The low byte (bits 0 through 7) of each data type occupies the lowest address in memory and that address is also the address of the operand.</p></blockquote><p>Where the adress is is not so important. What you need to know is that the next quadword after a quadword at address ‘addr’ is at ‘addr+8’.</p><p>Because adding these multiples is tedious and error‐prone, the multiplication is often written out expicitly. Sor the fifth wadqord up form address ‘addr’ is ‘addr+5<8’/>Written like this, the next quadword would be ‘addr+1<8’/>(the same as ‘addr+8’).</p><h2>The LEA instruction</h2><p>This instruction returns the effective address of the second operand,</p><pre>    lea rax [rsp+8]</pre><p>puts the address ‘rsp+8’ in ‘rax’. Otherwise,</p><pre>    mov rax [rsp+8]</pre><p>Would put the contents at ‘rsp+8’ in ‘rax’. Withoiut ‘lea’ you woulkd write,</p><pre><code>    mov rax rsp
    add rax, 8</code></pre><h3>Little note on LEA</h3><p>LEA can do arithmetic on it’s parameters. This is fast with compact notation. So you may find code like,</p><pre><code>main:
    enter 0,0
    pushNonVolatile

    mov rbx, 77
    lea rax, [5*rbx+7]
    println64 rax


    popNonVolatile
    mov rax,0
    leave
    ret</code></pre><p>Which loads ‘eax’ with ‘392’, from ‘5<77+7’/>But the result must be a legal address, which can limit the trick.</p></article></body></html>