<!DOCTYPE html><html><head><title>5_external_calls_printing</title><meta http-equiv="content-type" content="text/html; charset=UTF-8" /><link rel="stylesheet" type="text/css" media="screen" href="../lib/doc.css"/></head><body><article><h1>5 External calls and printing</h1><p>This section is here because it stands alone. If you prefer, you can skim this section then, when you need to understand, come back.</p><p>Throughout these posts we are going to use a basic code setup—a rig. This rig will enable us to paste code in without worrying about setup, and print result values (and will include a few more chunks of code to help move the posts along). Well, we start the rig here.</p><p>Assembly language has little concern for printing. The web makes a big show, in ‘Hello World’ examples, of printing using system interrupts. We would like something faster to code and more comprehensive, so the rig will print using the C Standard Library. So we can talk about how to call external code. Later, we cover other details about external calling, but this post will bring results.</p><h2>Using other libraries</h2><p>The ‘Hello world’ code on the web tends to use a direct system call to Linux. This is limited. Credit to Wikipedia—they at least present an example (even if currently non‐working) using the C library.</p><p>But we will use the C Standard Library. One reason is because object file symbols need to be linked to the library contents. This can, in some setups, be a difficult and troublesome process. But with the Linux linker, or ‘gcc’, it is fairly easy. ‘gcc’ has a C library builtin. Hurrah! No need for complex command lines! And the C library provides methods we need, and has been heavily developed. For a tutorial, that’s ok.</p><h2>Calling sub‐programs in libraries</h2><h3>Calling conventions</h3><p>The way to call another library is called a ‘convention’. Because how to call was never agreed, and depends on the type of the computer (the ‘architecture’), to some extent the operating system, and the library used. But how to get CPU instructions calling compiled libraries is a fundamental piece of computer programming. Who wants to work with a computer which can only run entirely stand‐alone compiled programs? So calling conventions have standards attached to them anyway.</p><ul><dd>Official C API conventions, on Github,</dd><dt><a href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI">https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI</a></dt><dd>NASM documentation on Unix‐based 64‐bit C API conventions (AT&T‐syntax),</dd><dt><a href="http://www.nasm.us/links/unix64abi">http://www.nasm.us/links/unix64abi</a></dt></ul><h3>The name of a called function</h3><p>We’re going to use ‘printf’ from the standard C library. So the function is called ‘printf’, isn’t it? No. If you thought you might call an external function by it’s name, you’d be wrong. Usually, the name is prefixed by an underscore—so ‘_printf’, not ‘printf’. NASM documentation,</p><blockquote><h4>9.1.1 External Symbol Names</h4><p>Most 32‐bit C compilers share the convention used by 16‐bit compilers, that the names of all global symbols (functions or data) they define are formed by prefixing an underscore to the name as it appears in the C program. However, not all of them do: the ELF specification states that C symbols do not have a leading underscore on their assembly‐language names.</p></blockquote><p>Ah. We are using the ELF output format. So guess what? ELF does not require the underscore. External calls can be named as if they were another module in the same language. Which, in a sense, they are.</p><p>I said we will take easy routes, we are using ELF files, so no fancy function naming for us. However, someday you may be glad if you remember this note.</p><h3>Passing parameters</h3><p>Right, if you were looking at this conceptually, you may be asking, “How do we get parameters into a function, when no parameters are available and we simply jump around?” (I could have started by calling functions with no parameters, but that’s no fun).</p><p>For 16‐bit and 32‐bit, we push on the stack. Then call the function. The conventions say that the called code then looks at the stack to see parameters. NASM documentation,</p><blockquote><h4>8.4.3 Function Definitions and Function Calls</h4><p>The C calling convention in 16‐bit programs is as follows. In the following description, the words caller and callee are used to denote the function doing the calling and the function which gets called.</p><p>The caller pushes the function’s parameters on the stack, one after another, in reverse order (right to left, so that the first argument specified to the function is pushed last)</p></blockquote><p>That’s clear enough. And you can find 32‐bit assembly programs on the web that do that.</p><p>But here is 64‐bit,</p><blockquote><h4>11.3 Interfacing to 64‐bit C Programs (Unix)</h4><p>…What follows is a simplified summary.</p><p>The first six integer arguments (from the left) are passed in RDI, RSI, RDX, RCX, R8, and R9, in that order. Additional integer arguments are passed on the stack. These registers, plus RAX, R10 and R11 are destroyed by function calls, and thus are available for use by the function without saving.</p></blockquote><p>Oh, see, the first few parameters are passed through the registers. In conventional notation, and assembly language, that will be a mess of ‘move’ instructions. However, the data is likely to be in registers anyway. Moreover, on a computer chip, the registers are themselves usually implemented as a stack. To a CPU, this is consistent. Lucky them, huh?</p><p>This difference in parameter passing to external functions is our first reason why 64‐bit assembly code, for x86 processors, is notably different to 32‐bit code.</p><h2>Printing out</h2><p>The C library ‘printf’ command takes several parameters, starting with a format string. In C, the code we will write looks like,</p><pre><code>    string s;
    s = "Aye";
    printf("%s", s);</code></pre><p>Add these lines to the rig,</p><pre><code>extern printf

SECTION .data
    strToPrint: db 'Aye', 0Ah, 0h
    fmt: db "%s", 10, 0	

SECTION .text

global main
main:
    push rbp

    mov rdi,fmt
	mov	rsi, strToPrint
    call printf


    pop rbp
    mov rax,0	
    ret</code></pre><p>To spare confusion, here’s the x86 32‐bit version. The registers have 32‐bit names, and the code needs to be compiled with the x86 32‐bit commands (I’m not going to provide 32‐bit code all the time, or it will bloat the text),</p><pre><code>extern printf

SECTION .data
    strToPrint: db 'Aye', 0Ah, 0h
    fmt: db "%s", 10, 0	

SECTION .text

global main
main:
    push ebp

    push fmt
	push strToPrint
    call printf


    pop ebp
    mov eax,0	
    ret</code></pre><p>There’s a lot going on here. Try it first, check it works.</p><p>The ‘printf’ call is tagged in using the ‘extern printf’ command. ‘extern’ means ‘no code here now, if used will be provided later through a linker’. And then we linked using ‘gcc’, which includes the library, so the code was found, and the executable could be made.</p><p>The ‘strToPrint’ and ‘fmt’ marks attach labels to data definitions. I put them there so you could see this working. If you don’t fully get it right now—and I agree I have not explained much—don’t worry. They are there to give us something to work with. We’ll cover data definitions later.</p><p>The label ’strToPrint’ is a pointer to a string value. That concept is ok for those who have programmed in C. If you havn’t quite got that, we’ll cover it later. You’ll be ok.</p><p>You can see the parameter passing conventions at work. In the 64‐bit version, the format string and pointer to the string value are ‘mov’ed (moved) to the ‘rdi’ and ‘rsi’ registers. In the 32‐bit versions, they are pushed onto the stack.</p><p>At the end of the the code, we move a ‘0’ onto the ‘rax‘ register before exiting. That sets a return code. ‘0’ means all went well. You may recognise this code from the previous post.</p><p>Finally, what are the two commands for that push the base pointer register value (xBP) onto the stack, then pop it again later? What is going on with the base pointer? We don’t use it?</p><h2>The base pointer</h2><p>If you fancy digging through it, here is the NASM documentation (from the C api sections). For us here, ‘caller’ is the C code through which the assembly code, the ‘callee’ is run,</p><blockquote><p>The callee receives control, and typically (although this is not actually necessary, in functions which do not need to access their parameters) starts by saving the value of SP in BP so as to be able to use BP as a base pointer to find its parameters on the stack. However, the caller was probably doing this too, so part of the calling convention states that BP must be preserved by any C function. Hence the callee, if it is going to set up BP as a frame pointer, must push the previous value first.</p></blockquote><p>Writing as algorithm…</p><p>You don’t need to understand this now. We’ll cover the idea fully later. But in short—the assembly program ‘main’ stashes the base pointer because programs love to mess round with it. ‘printf’ itself probably messes round with the pointer—we hope it restores it too. But hark at this — if we remove the restoration, the programs throw a segfault. That’s because ???.</p><h2>Charms</h2><p>Ok, we covered a lot of ground. And a lot of that ground was warnings and charms. That’s machine code for you. But we do have a library call, and a working printout.</p><p>If you went away from here and tried to program your own external call, if the call had only had one parameter and was an int, it may work. That’s a start.</p><h4></h4><p>usually annotated as being for stream source and stream destinations, and descripbed last in the resister list, are suddenly pressed into use for carrying the first two parameters.</p><p>We might also be preserving as the registers like RBX, RDI, and RSI.</p></article></body></html>